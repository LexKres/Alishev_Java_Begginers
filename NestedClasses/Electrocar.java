package NestedClasses;

public class Electrocar {
    private int id;

    // вложенный нестатический класс (обычно private, т.к. используется внутри самого класса)
    private class Motor {
        public void startMotor() {
            System.out.println("Motor " + id + " is starting...");
        }
    }

    // вложенный статический класс (обычно public) (не имеет доступа к нестатическим данным класса)
    // и статические данные - это единственное, что связывает такой вложенный класс с классом, в котором он создан
    // ну и еще логика использования
    // статические вложенные классы нужны обычно для использования вовне (поэтому обычно они public)
    public static class Battery {
        public void charge() {
            System.out.println("Battery is charging...");
        }
    }

    public Electrocar (int id) {
        this.id = id;
    }

    public void start() {
        Motor motor = new Motor();
        motor.startMotor();

        final int x = 1;

        // вложенный класс в методе
        // переменные метода, к которым может иметь доступ такой вложенный класс, должны быть константами, т.е. final
        // см. пояснение в конце
        // а к переменным основного класса доступ есть без ограничений
        // вложенный класс в методе похож на анонимный класс, просто вместо создания анонимного класса можно сделать и так
        class SomeClass {
            public void someMethod() {
                System.out.println(x);
                System.out.println(id);
            }
        }

        SomeClass someObject = new SomeClass();
        // создав объект такого вложенного в метод класса, его можно передать как параметр
        test(someObject);

        System.out.println("Electrocar " + id + " is starting...");
    }

    private void test(Object obj) {

    }
}

/* Алишев:
Все дело в том, что при создании объекта вложенного класса внутри метода все переменные метода копируются в объект
этого вложенного класса. То есть переменные в методе и переменные во вложенном в этот метод классе - это две разные
переменные, которые имеют одинаковое значение.

Пример:
public void test() {
    final int a = 5; // эта переменная
    class SomeClass {
        public void someMethod() {
            a = 1; // отличается от этой переменной
        }
    }
}

Имея в виду такую особенность реализации вложенных классов в Java, разработчики языка решили, что возможность
передавать во вложенные классы не константы приведет к путанице.

Какого рода путаница?
Если бы вы могли передавать во вложенные классы переменные-неконстанты, то вы бы могли изменять их внутри вложенных
классов. Тогда, изменив переменную внутри класса, вы бы ожидали, что она изменится и в самом методе-обертке, но этого
не произойдет потому, что в методе и во вложенном классе хранятся разные переменные.

И наоборот, изменяя переменную в методе, вы бы ожидали, что она изменится во вложенном классе, но этого не произойдет.

Поэтому, чтобы такой путаницы не возникало, во вложенные классы можно передавать только final переменные.
 */